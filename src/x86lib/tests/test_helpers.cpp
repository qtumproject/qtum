#include "x86lib.h"
#include "x86lib_internal.h"

#include "x86test.h"
#include "catch.hpp"

#include <iostream>
#include <fstream>

x86Tester::x86Tester(){
    cpu.Memory = &memory;
    cpu.Ports = &ports;
    coderom = new ROMemory(CODE_SIZE, "code");
    scratchram = new RAMemory(SCRATCH_SIZE, "scratch");
    highscratchram = new RAMemory(SCRATCH_SIZE, "scratch");
    stackram = new RAMemory(STACK_SIZE, "stack");
    memset(coderom->GetMemory(), 0, CODE_SIZE);
    memset(scratchram->GetMemory(), 0, SCRATCH_SIZE);
    memset(highscratchram->GetMemory(), 0, SCRATCH_SIZE);
    memset(stackram->GetMemory(), 0, STACK_SIZE);
    memory.Add(CODE_ADDRESS, CODE_ADDRESS+CODE_SIZE, coderom);
    memory.Add(SCRATCH_ADDRESS, SCRATCH_ADDRESS + SCRATCH_SIZE, scratchram);
    memory.Add(HIGH_SCRATCH_ADDRESS, HIGH_SCRATCH_ADDRESS + SCRATCH_SIZE, highscratchram);
    memory.Add(STACK_ADDRESS, STACK_ADDRESS + STACK_SIZE, stackram);

    testports = new TestPorts(&cpu);
    ports.Add(0xFF, 0xFF, testports); //register port for exit

    cpu.Reset();
    cpu.SetRegister32(ESP, STACK_ADDRESS + STACK_START);
    //EIP is already set to 0x1000
    cacheValid = false;
}
//Assembles the given code as assembly
void x86Tester::Assemble(string code){
    ofstream file;
    file.open("tmp_generated.asm", ios::out | ios::trunc);
    file << ";This code is AUTOGENERATED by the test suite!" << endl;
    file << "CPU i386" << endl
         << "BITS 32" << endl
         << "ORG 0x1000" << endl
         //some useful macros
         << "%define CODE_ADDRESS 0x1000" << endl
         << "%define STACK_ADDRESS 0x2000" << endl
         << "%define SCRATCH_ADDRESS 0x3000" << endl
         << "%define HIGH_SCRATCH_ADDRESS 0xFABF3000" << endl
         << "_start:" << endl
         << code << endl
         << "_end:" << endl
         << "out 0xFF, al" << endl; //terminates execution (al is ignored)

    file.close();
    REQUIRE(system("yasm -o tmp_generated.bin tmp_generated.asm") == 0);
    //file is assembled, now load it
    LoadFile("tmp_generated.bin");
}
//loads a raw binary file
void x86Tester::LoadFile(string fileName){
    ifstream file(fileName.c_str(), ios::binary);
    REQUIRE(file);
    file.seekg(0, std::ios::end);
    int fileLength = (uint32_t) ((long)file.tellg());
    file.seekg(0, std::ios::beg);
    REQUIRE(fileLength < CODE_SIZE);
    REQUIRE(fileLength > 0);
    file.read(coderom->GetMemory(), fileLength);
    cacheValid = false;
}
//Loads the current x86 state into the checkpoint field
x86Checkpoint x86Tester::LoadCheckpoint(){
    x86Checkpoint checkpoint;
    cpu.SaveState(&checkpoint.regs);
    memcpy(checkpoint.stack, stackram->GetMemory(), STACK_SIZE);
    memcpy(checkpoint.scratch, scratchram->GetMemory(), SCRATCH_SIZE);
    memcpy(checkpoint.highscratch, highscratchram->GetMemory(), SCRATCH_SIZE);
    return checkpoint;
}
//Loads the checkpoint data into the x86 VM
void x86Tester::Apply(x86Checkpoint& checkpoint){
    cpu.LoadState(checkpoint.regs);
    memcpy(stackram->GetMemory(), checkpoint.stack, STACK_SIZE);
    memcpy(scratchram->GetMemory(), checkpoint.scratch, SCRATCH_SIZE);
    memcpy(highscratchram->GetMemory(), checkpoint.highscratch, SCRATCH_SIZE);
    cacheValid = false;
}
//Runs the x86 VM for the specified number of instructions
void x86Tester::Run(int count){
    cpu.Exec(count);
    cacheValid = false;
}

void x86Tester::Compare(x86Checkpoint &check, bool checkeip, bool checkMemory){
    x86Checkpoint checkpoint = LoadCheckpoint();
    //don't use a loop here for easier diagnostics when it fails
    REQUIRE(check.regs.regs32[EAX] == checkpoint.regs.regs32[EAX]);
    REQUIRE(check.regs.regs32[ECX] == checkpoint.regs.regs32[ECX]);
    REQUIRE(check.regs.regs32[EDX] == checkpoint.regs.regs32[EDX]);
    REQUIRE(check.regs.regs32[EBX] == checkpoint.regs.regs32[EBX]);
    REQUIRE(check.regs.regs32[ESP] == checkpoint.regs.regs32[ESP]);
    REQUIRE(check.regs.regs32[EBP] == checkpoint.regs.regs32[EBP]);
    REQUIRE(check.regs.regs32[ESI] == checkpoint.regs.regs32[ESI]);
    REQUIRE(check.regs.regs32[EDI] == checkpoint.regs.regs32[EDI]);

    REQUIRE(check.regs.freg.bits.cf == checkpoint.regs.freg.bits.cf);
    REQUIRE(check.regs.freg.bits.of == checkpoint.regs.freg.bits.of);
    REQUIRE(check.regs.freg.bits.pf == checkpoint.regs.freg.bits.pf);
    REQUIRE(check.regs.freg.bits.af == checkpoint.regs.freg.bits.af);
    REQUIRE(check.regs.freg.bits.zf == checkpoint.regs.freg.bits.zf);
    REQUIRE(check.regs.freg.bits.sf == checkpoint.regs.freg.bits.sf);
    REQUIRE(check.regs.freg.bits._if == checkpoint.regs.freg.bits._if);

    REQUIRE(check.regs.seg[cES] == checkpoint.regs.seg[cES]);
    REQUIRE(check.regs.seg[cCS] == checkpoint.regs.seg[cCS]);
    REQUIRE(check.regs.seg[cSS] == checkpoint.regs.seg[cSS]);
    REQUIRE(check.regs.seg[cDS] == checkpoint.regs.seg[cDS]);
    REQUIRE(check.regs.seg[cFS] == checkpoint.regs.seg[cFS]);
    REQUIRE(check.regs.seg[cGS] == checkpoint.regs.seg[cGS]);
    if(checkeip){
        REQUIRE(check.regs.eip == checkpoint.regs.eip);
    }
    if(checkMemory){
        REQUIRE(memcmp(check.stack, checkpoint.stack, STACK_SIZE) == 0);
        REQUIRE(memcmp(check.scratch, checkpoint.scratch, SCRATCH_SIZE) == 0);
        REQUIRE(memcmp(check.highscratch, checkpoint.highscratch, SCRATCH_SIZE) == 0);
    }
}
x86Checkpoint& x86Tester::Check(){
    if(!cacheValid){
        cache=LoadCheckpoint();
    }
    return cache;
}
